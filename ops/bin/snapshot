#!/usr/bin/env bash
set -euo pipefail

scope="icl"
format="chatgpt"
out_path=""
compress_mode=""
bundle_mode=0
max_lines=""
state_of_play_entry_limit=15
state_heading_regex='^## [0-9]{4}-[0-9]{2}-[0-9]{2} '

usage() {
  cat <<'USAGE'
Usage: ops/bin/snapshot [--scope=icl|platform|full] [--format=chatgpt|gemini|claude] [--max-lines=n] [--out=path|auto]
                     [--compress=tar.xz] [--bundle]
USAGE
}

die() {
  echo "ERROR: $*" >&2
  usage >&2
  exit 1
}

for arg in "$@"; do
  case "$arg" in
    --scope=icl|--scope=platform|--scope=full)
      scope="${arg#--scope=}"
      ;;
    --format=chatgpt|--format=gemini|--format=claude)
      format="${arg#--format=}"
      ;;
    --max-lines=*)
      max_lines="${arg#--max-lines=}"
      if [[ -z "$max_lines" ]]; then
        die "--max-lines requires a value"
      fi
      if ! [[ "$max_lines" =~ ^[0-9]+$ ]]; then
        die "--max-lines must be a non-negative integer"
      fi
      ;;
    --out=*)
      out_path="${arg#--out=}"
      if [[ -z "$out_path" ]]; then
        die "--out requires a path"
      fi
      if [[ "$out_path" == "auto.tar.xz" ]]; then
        out_path="auto"
        compress_mode="tar.xz"
      fi
      ;;
    --compress=tar.xz)
      compress_mode="tar.xz"
      ;;
    --bundle|--bundle=receipt)
      bundle_mode=1
      ;;
    *)
      die "Unknown argument: $arg"
      ;;
  esac
done

if [[ -n "$out_path" && "$out_path" != "auto" && -z "$compress_mode" ]]; then
  case "$out_path" in
    *.tar.xz)
      compress_mode="tar.xz"
      ;;
  esac
fi

if [[ -n "$compress_mode" && -z "$out_path" ]]; then
  die "--compress requires --out"
fi

if [[ "$bundle_mode" -eq 1 && -n "$out_path" && -z "$compress_mode" ]]; then
  compress_mode="tar.xz"
fi

if [[ -z "$max_lines" ]]; then
  if [[ "$scope" == "icl" ]]; then
    max_lines=400
  else
    max_lines=0
  fi
fi

if [[ "$scope" == "full" && "$out_path" == "auto" && -z "$compress_mode" ]]; then
  compress_mode="tar.xz"
fi

if ! command -v git >/dev/null 2>&1; then
  die "git is required but was not found on PATH."
fi

if ! repo_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  die "git repo not found. Run from repo root."
fi

if [[ "$(pwd -P)" != "$repo_root" ]]; then
  die "Run from repo root: $repo_root"
fi

mkdir -p "$repo_root/storage/handoff"

remote_url="$(git remote get-url origin 2>/dev/null || true)"
if [[ -n "$remote_url" ]]; then
  repo_name="$(basename -s .git "$remote_url")"
else
  repo_name="$(basename "$repo_root")"
fi

branch="$(git rev-parse --abbrev-ref HEAD)"
head_short="$(git rev-parse --short HEAD)"
branch_safe="${branch//\//-}"
snapshot_base="snapshot-${scope}-${branch_safe}-${head_short}"
payload_path="$repo_root/storage/snapshots/${snapshot_base}.txt"
manifest_path="$repo_root/storage/snapshots/${snapshot_base}.manifest.txt"

format_label="$format"
case "$format" in
  chatgpt)
    format_label="ChatGPT"
    ;;
  gemini)
    format_label="Gemini"
    ;;
  claude)
    format_label="Claude"
    ;;
esac

ICL_FILES=(
  "PROJECT_TRUTH.md"
  "STATE_OF_PLAY.md"
  "PROJECT_MAP.md"
  "CANONICAL_TREE.md"
  "docs/00-INDEX.md"
  "ops/init/icl/ICL_CONTINUITY_CORE.md"
  "ops/init/icl/CONTEXT_PACK.md"
  "ops/init/icl/AI_CONTEXT_SYNC.md"
  "ops/init/icl/context_pack.json"
  "ops/bin/open"
  "ops/bin/close"
  "ops/bin/snapshot"
)

is_excluded_path() {
  if [[ "$scope" == "platform" ]]; then
    case "$1" in
      projects/*|public_html/*)
        return 0
        ;;
    esac
  fi
  case "$1" in
    .git/*|*/.git/*|storage/*|vendor/*|*/vendor/*|node_modules/*|*/node_modules/*|upstream/*|addons/_bundled_snapshot/*|archives/*|archive/*|docs/_archive/*|docs/archive/*|docs/archives/*|*/_archive/*|*/archives/*|*/archive/*)
      return 0
      ;;
  esac
  return 1
}

is_excluded_ext() {
  local lower
  lower="$(printf "%s" "$1" | tr '[:upper:]' '[:lower:]')"
  case "$lower" in
    *.png|*.jpg|*.jpeg|*.gif|*.svg|*.ico|*.pdf|*.zip|*.tar|*.gz|*.xz|*.tgz|*.7z|*.rar|*.mp3|*.mp4|*.mov|*.avi|*.mkv|*.webm|*.ogg|*.wav|*.woff|*.woff2|*.ttf|*.otf|*.class|*.jar|*.exe|*.dll|*.so|*.dylib|*.psd|*.ai|*.sketch|*.doc|*.docx|*.xls|*.xlsx|*.ppt|*.pptx)
      return 0
      ;;
  esac
  return 1
}

collect_files() {
  local path
  while IFS= read -r path; do
    [[ -z "$path" ]] && continue
    if is_excluded_path "$path"; then
      continue
    fi
    if is_excluded_ext "$path"; then
      continue
    fi
    echo "$path"
  done
}

files=()
if [[ "$scope" == "icl" ]]; then
  missing=()
  for path in "${ICL_FILES[@]}"; do
    if [[ ! -f "$path" ]]; then
      missing+=("$path")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    echo "ERROR: expected files missing. Run from repo root." >&2
    for path in "${missing[@]}"; do
      echo "  - $path" >&2
    done
    exit 1
  fi
  files=("${ICL_FILES[@]}")
else
  mapfile -t files < <(git ls-files | collect_files)
fi

output_target=""
archive_path=""
if [[ -n "$out_path" ]]; then
  if [[ "$out_path" == "auto" ]]; then
    if [[ "$compress_mode" == "tar.xz" ]]; then
      output_target="$repo_root/storage/snapshots/${snapshot_base}.tar.xz"
    else
      output_target="$payload_path"
    fi
  elif [[ "$out_path" = /* ]]; then
    output_target="$out_path"
  else
    output_target="$repo_root/$out_path"
  fi
fi
if [[ -z "$output_target" ]]; then
  archive_path="$repo_root/storage/snapshots/${snapshot_base}.tar.xz"
elif [[ "$compress_mode" == "tar.xz" ]]; then
  archive_path="$output_target"
fi
mkdir -p "$(dirname "$payload_path")"
if [[ -n "$output_target" ]]; then
  mkdir -p "$(dirname "$output_target")"
fi

count_lines() {
  awk 'END { print NR }' "$1"
}

count_state_of_play_headings() {
  LC_ALL=C grep -cE "$state_heading_regex" "$1" || true
}

count_state_of_play_limited_lines() {
  awk -v limit="$state_of_play_entry_limit" -v regex="$state_heading_regex" '
    $0 ~ regex { entry++ }
    entry == 0 || entry <= limit { lines++ }
    entry > limit { exit }
    END { print lines }
  ' "$1"
}

emit_file_contents() {
  local path="$1"
  local suppress_pipe_errors="$2"
  local max="$3"
  if [[ ! -f "$path" ]]; then
    echo "(missing file)"
    return 0
  fi
  if (( max > 0 )); then
    if [[ "$suppress_pipe_errors" -eq 1 ]]; then
      awk -v max="$max" '{
        total++
        if (total <= max) {
          print
        }
      }
      END {
        if (total > max) {
          print "(...truncated at " max " lines; use --scope=full or --max-lines=0 for complete)"
        }
      }' "$path" 2>/dev/null || true
    else
      awk -v max="$max" '{
        total++
        if (total <= max) {
          print
        }
      }
      END {
        if (total > max) {
          print "(...truncated at " max " lines; use --scope=full or --max-lines=0 for complete)"
        }
      }' "$path"
    fi
  else
    if [[ "$suppress_pipe_errors" -eq 1 ]]; then
      cat "$path" 2>/dev/null || true
    else
      cat "$path"
    fi
  fi
}

emit_state_of_play_contents() {
  local path="$1"
  local suppress_pipe_errors="$2"
  local max="$3"
  local heading_total
  if [[ ! -f "$path" ]]; then
    echo "(missing file)"
    return 0
  fi
  heading_total=$(count_state_of_play_headings "$path")
  if (( heading_total == 0 )); then
    emit_file_contents "$path" "$suppress_pipe_errors" "$max"
    return 0
  fi
  if [[ "$suppress_pipe_errors" -eq 1 ]]; then
    awk -v limit="$state_of_play_entry_limit" -v max="$max" -v regex="$state_heading_regex" '
      $0 ~ regex { entry++ }
      entry == 0 || entry <= limit {
        total++
        if (max == 0 || total <= max) {
          print
        }
      }
      entry > limit { exit }
      END {
        if (max > 0 && total > max) {
          print "(...truncated at " max " lines; use --scope=full or --max-lines=0 for complete)"
        }
      }
    ' "$path" 2>/dev/null || true
  else
    awk -v limit="$state_of_play_entry_limit" -v max="$max" -v regex="$state_heading_regex" '
      $0 ~ regex { entry++ }
      entry == 0 || entry <= limit {
        total++
        if (max == 0 || total <= max) {
          print
        }
      }
      entry > limit { exit }
      END {
        if (max > 0 && total > max) {
          print "(...truncated at " max " lines; use --scope=full or --max-lines=0 for complete)"
        }
      }
    ' "$path"
  fi
}

is_file_truncated() {
  local path="$1"
  local heading_total
  local lines
  local limited_lines

  if [[ ! -f "$path" ]]; then
    return 1
  fi

  if [[ "$scope" == "icl" && "$path" == "STATE_OF_PLAY.md" ]]; then
    heading_total=$(count_state_of_play_headings "$path")
    if (( heading_total == 0 )); then
      if (( max_lines > 0 )); then
        lines=$(count_lines "$path")
        if (( lines > max_lines )); then
          return 0
        fi
      fi
      return 1
    fi
    if (( heading_total > state_of_play_entry_limit )); then
      return 0
    fi
    if (( max_lines > 0 )); then
      limited_lines=$(count_state_of_play_limited_lines "$path")
      if (( limited_lines > max_lines )); then
        return 0
      fi
    fi
    return 1
  fi

  if (( max_lines > 0 )); then
    lines=$(count_lines "$path")
    if (( lines > max_lines )); then
      return 0
    fi
  fi
  return 1
}

emit_snapshot() {
  local suppress_pipe_errors=0
  local files_count
  local truncated_files=0
  if [[ -p /proc/$$/fd/1 ]]; then
    suppress_pipe_errors=1
    exec 2>/dev/null
  fi

  files_count=${#files[@]}
  for path in "${files[@]}"; do
    if is_file_truncated "$path"; then
      truncated_files=$((truncated_files + 1))
    fi
  done

  echo "===== REPO SNAPSHOT ====="
  echo "Repo: $repo_name"
  echo "Branch: $branch"
  echo "HEAD: $head_short"
  echo "Scope: $scope"
  echo "Format: $format_label"
  echo "Files included: $files_count"
  echo "Truncated files: $truncated_files"
  excluded_dirs=".git/ storage/ vendor/ node_modules/ upstream/ addons/_bundled_snapshot/ archives/ archive/ docs/_archive/ docs/archive/ docs/archives/ */_archive/ */archive/ */archives/"
  if [[ "$scope" == "platform" ]]; then
    excluded_dirs+=" projects/ public_html/"
  fi
  echo "Excluded dirs: $excluded_dirs"
  echo "Excluded types: .png .jpg .jpeg .gif .svg .ico .pdf .zip .tar .gz .xz .tgz .7z .rar .mp3 .mp4 .mov .avi .mkv .webm .ogg .wav .woff .woff2 .ttf .otf .class .jar .exe .dll .so .dylib .psd .ai .sketch .doc .docx .xls .xlsx .ppt .pptx"
  echo "===== SNAPSHOT PAYLOAD BEGIN ====="
  echo "[INDEX]"
  for path in "${files[@]}"; do
    echo "- $path"
  done
  echo ""
  echo "[FILE CONTENTS]"
  for path in "${files[@]}"; do
    echo "<<< FILE BEGIN: $path"
    if [[ "$scope" == "icl" && "$path" == "STATE_OF_PLAY.md" ]]; then
      emit_state_of_play_contents "$path" "$suppress_pipe_errors" "$max_lines"
    else
      emit_file_contents "$path" "$suppress_pipe_errors" "$max_lines"
    fi
    echo ">>> FILE END: $path"
    echo ""
  done
  echo "===== SNAPSHOT PAYLOAD END ====="
}

emit_manifest() {
  local path="$1"
  local payload="$2"
  local output="$3"
  local files_count="${#files[@]}"
  {
    echo "Snapshot Manifest"
    echo "Branch: $branch"
    echo "HEAD: $head_short"
    echo "Scope: $scope"
    echo "Format: $format_label"
    echo "Chat payload: $payload"
    if [[ -n "$output" ]]; then
      echo "Output target: $output"
    else
      echo "Output target: (stdout)"
    fi
    echo "Files included: $files_count"
    echo "Included files:"
    for path in "${files[@]}"; do
      echo "- $path"
    done
  } > "$path"
}

emit_snapshot > "$payload_path"

manifest_output="$output_target"
if [[ -z "$manifest_output" && -n "$archive_path" ]]; then
  manifest_output="$archive_path"
fi

if [[ "$bundle_mode" -eq 1 ]]; then
  emit_manifest "$manifest_path" "$payload_path" "$manifest_output"
fi

if [[ -z "$output_target" ]]; then
  cat "$payload_path"
fi

if [[ -n "$archive_path" ]]; then
  if ! command -v tar >/dev/null 2>&1; then
    die "tar is required for snapshot archive output but was not found on PATH."
  fi
  tar_items=()
  tar_items+=("$(basename "$payload_path")")
  if [[ "$bundle_mode" -eq 1 ]]; then
    tar_items+=("$(basename "$manifest_path")")
  fi
  tar -cJf "$archive_path" -C "$(dirname "$payload_path")" "${tar_items[@]}"
elif [[ -n "$output_target" && "$output_target" != "$payload_path" ]]; then
  cp "$payload_path" "$output_target"
fi

if [[ "$bundle_mode" -eq 0 ]]; then
  emit_manifest "$manifest_path" "$payload_path" "$manifest_output"
fi

echo "Snapshot payload: $payload_path"
if [[ -n "$archive_path" ]]; then
  echo "Snapshot tarball: $archive_path"
fi
echo "Snapshot manifest: $manifest_path"
