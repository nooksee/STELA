#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_PATH="$SCRIPT_DIR/../lib/project/project_lib.sh"

if [[ ! -f "$LIB_PATH" ]]; then
  echo "ERROR: Missing project library: $LIB_PATH" >&2
  exit 1
fi

# shellcheck source=../lib/project/project_lib.sh
source "$LIB_PATH"

usage() {
  cat <<'USAGE'
Usage: ops/bin/project <command> [args]

Commands:
  list
    Print a concise list of registered projects.

  current
    Print the current project id, or "none" if unset.

  init <name> --dry-run|--confirm
    Register a new project and optionally create a minimal scaffold.
    Use --dry-run to preview changes; use --confirm to apply.

  new --name "<Display Name>" [--id <project_id>] [--slug <slug>] --dry-run|--confirm
    Create a new project with optional id/slug overrides and the standard scaffold.
    Uses a generated project id and a slugified name when omitted.

  use <project_id> --dry-run|--confirm
    Set the current project pointer to a registered project id.
USAGE
}

die() {
  echo "ERROR: $*" >&2
  usage >&2
  exit 1
}

cmd_list() {
  local any=0
  local id name created status root notes

  while IFS=$'\t' read -r id name created status root notes; do
    if (( any == 0 )); then
      printf "project_id | status | root_path | display_name\n"
      any=1
    fi
    printf "%s | %s | %s | %s\n" "$id" "$status" "$root" "$name"
  done < <(project_lib_registry_rows)

  if (( any == 0 )); then
    echo "No registered projects."
  fi
}

cmd_current() {
  local current
  current="$(project_lib_get_current_project_id || true)"
  current="$(project_lib_trim "${current:-}")"

  if [[ -z "$current" || "$current" == "none" ]]; then
    echo "none"
    return 0
  fi

  echo "$current"
}

project_create() {
  local project_id="$1"
  local display_name="$2"
  local project_slug="$3"
  local dry_run="$4"
  local confirm="$5"
  local set_current="$6"

  if [[ -z "$project_id" ]]; then
    die "Missing project id."
  fi

  if [[ -z "$display_name" ]]; then
    die "Missing project name."
  fi

  if [[ -z "$project_slug" ]]; then
    die "Missing project slug."
  fi

  if ! project_lib_is_valid_id "$project_id"; then
    die "Invalid project id: $project_id"
  fi

  if ! project_lib_is_valid_id "$project_slug"; then
    die "Invalid project slug: $project_slug"
  fi

  local root_path="projects/$project_slug"
  if [[ -e "$root_path" ]]; then
    die "Path already exists: $root_path"
  fi

  if project_lib_registry_has_id "$project_id"; then
    die "Project already registered: $project_id"
  fi

  if project_lib_registry_has_root_path "$root_path"; then
    die "Root path already registered: $root_path"
  fi

  local created_at status notes template
  created_at="$(date +%F)"
  status="active"
  notes=""
  template="$(project_lib_template_path)"

  if [[ ! -f "$template" ]]; then
    die "Missing template: $(project_lib_template_rel)"
  fi

  local subdirs=(upstream addons patches)
  local subdir
  for subdir in "${subdirs[@]}"; do
    local sub_template
    sub_template="$(project_lib_subdir_template_path "$subdir")"
    if [[ ! -f "$sub_template" ]]; then
      die "Missing template: $(project_lib_subdir_template_rel "$subdir")"
    fi
  done

  if (( dry_run == 1 )); then
    cat <<EOF
DRY RUN: would register project:
  project_id: $project_id
  display_name: $display_name
  created_at: $created_at
  status: $status
  root_path: $root_path

DRY RUN: would update registry: $(project_lib_registry_rel)
DRY RUN: would create $root_path/README.md from $(project_lib_template_rel)
EOF

    for subdir in "${subdirs[@]}"; do
      printf "DRY RUN: would create %s/%s/README.md from %s\n" \
        "$root_path" \
        "$subdir" \
        "$(project_lib_subdir_template_rel "$subdir")"
    done

    if (( set_current == 1 )); then
      printf "DRY RUN: would set current project to %s\n" "$project_id"
    fi
    return 0
  fi

  mkdir -p "$root_path"
  project_lib_render_template "$template" "$project_id" "$display_name" "$created_at" > "$root_path/README.md"

  for subdir in "${subdirs[@]}"; do
    mkdir -p "$root_path/$subdir"
    project_lib_render_template \
      "$(project_lib_subdir_template_path "$subdir")" \
      "$project_id" \
      "$display_name" \
      "$created_at" \
      > "$root_path/$subdir/README.md"
  done

  if ! project_lib_add_registry_entry "$project_id" "$display_name" "$created_at" "$status" "$root_path" "$notes"; then
    rm -f "$root_path/README.md"
    for subdir in "${subdirs[@]}"; do
      rm -f "$root_path/$subdir/README.md"
      rmdir "$root_path/$subdir" 2>/dev/null || true
    done
    rmdir "$root_path" 2>/dev/null || true
    die "Failed to register project."
  fi

  if (( set_current == 1 )); then
    if ! project_lib_set_current_project_id "$project_id"; then
      die "Failed to set current project."
    fi
  fi

  echo "Created project scaffold at $root_path and registered in $(project_lib_registry_rel)."
}

cmd_init() {
  local name=""
  local dry_run=0
  local confirm=0

  while (( $# > 0 )); do
    case "$1" in
      --dry-run)
        dry_run=1
        ;;
      --confirm)
        confirm=1
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      -* )
        die "Unknown flag: $1"
        ;;
      * )
        if [[ -z "$name" ]]; then
          name="$1"
        else
          die "Too many arguments."
        fi
        ;;
    esac
    shift
  done

  if [[ -z "$name" ]]; then
    die "Missing project name."
  fi

  if (( dry_run + confirm == 0 )); then
    die "Use --dry-run or --confirm."
  fi

  if (( dry_run == 1 && confirm == 1 )); then
    die "Choose only one of --dry-run or --confirm."
  fi

  local trimmed_name project_id project_slug
  trimmed_name="$(project_lib_trim "$name")"
  project_id="$(project_lib_slugify "$trimmed_name")"
  project_slug="$project_id"

  if [[ -z "$project_id" ]]; then
    die "Project name produced an empty id."
  fi

  project_create "$project_id" "$trimmed_name" "$project_slug" "$dry_run" "$confirm" 0
}

cmd_new() {
  local name=""
  local project_id=""
  local project_slug=""
  local dry_run=0
  local confirm=0

  while (( $# > 0 )); do
    case "$1" in
      --name)
        shift
        name="${1:-}"
        ;;
      --id)
        shift
        project_id="${1:-}"
        ;;
      --slug)
        shift
        project_slug="${1:-}"
        ;;
      --dry-run)
        dry_run=1
        ;;
      --confirm)
        confirm=1
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      -* )
        die "Unknown flag: $1"
        ;;
      * )
        die "Unknown argument: $1"
        ;;
    esac
    shift
  done

  if [[ -z "$name" ]]; then
    die "Missing --name."
  fi

  if (( dry_run + confirm == 0 )); then
    die "Use --dry-run or --confirm."
  fi

  if (( dry_run == 1 && confirm == 1 )); then
    die "Choose only one of --dry-run or --confirm."
  fi

  local trimmed_name
  trimmed_name="$(project_lib_trim "$name")"

  if [[ -z "$project_id" ]]; then
    project_id="$(project_lib_next_project_id)"
  fi

  if [[ -z "$project_slug" ]]; then
    project_slug="$(project_lib_slugify "$trimmed_name")"
  fi

  if [[ -z "$project_slug" ]]; then
    die "Project name produced an empty slug."
  fi

  project_create "$project_id" "$trimmed_name" "$project_slug" "$dry_run" "$confirm" 1
}

cmd_use() {
  local project_id=""
  local dry_run=0
  local confirm=0

  while (( $# > 0 )); do
    case "$1" in
      --dry-run)
        dry_run=1
        ;;
      --confirm)
        confirm=1
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      -* )
        die "Unknown flag: $1"
        ;;
      * )
        if [[ -z "$project_id" ]]; then
          project_id="$1"
        else
          die "Too many arguments."
        fi
        ;;
    esac
    shift
  done

  if [[ -z "$project_id" ]]; then
    die "Missing project id."
  fi

  if (( dry_run + confirm == 0 )); then
    die "Use --dry-run or --confirm."
  fi

  if (( dry_run == 1 && confirm == 1 )); then
    die "Choose only one of --dry-run or --confirm."
  fi

  if ! project_lib_registry_has_id "$project_id"; then
    die "Project not registered: $project_id"
  fi

  if (( dry_run == 1 )); then
    echo "DRY RUN: would set current project to $project_id"
    return 0
  fi

  if ! project_lib_set_current_project_id "$project_id"; then
    die "Failed to set current project."
  fi

  echo "Current project set to $project_id."
}

project_lib_require_repo_root

case "${1:-}" in
  list )
    cmd_list
    ;;
  current )
    cmd_current
    ;;
  init )
    shift
    cmd_init "$@"
    ;;
  new )
    shift
    cmd_new "$@"
    ;;
  use )
    shift
    cmd_use "$@"
    ;;
  -h|--help|"" )
    usage
    ;;
  * )
    die "Unknown command: $1"
    ;;
esac
