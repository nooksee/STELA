#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
OUT_DIR="${REPO_ROOT}"

usage() {
  cat <<'USAGE'
Usage: ops/bin/llms [--out-dir=PATH]
USAGE
}

for arg in "$@"; do
  case "$arg" in
    --out-dir=*)
      OUT_DIR="${arg#--out-dir=}"
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "ERROR: Unknown arg: ${arg}" >&2
      exit 1
      ;;
  esac
done

SMALL_OUT="${OUT_DIR}/llms-small.txt"
FULL_OUT="${OUT_DIR}/llms-full.txt"

strip_toc() {
  awk '
    BEGIN { skip=0 }
    /^## (Table of Contents|Contents|TOC)$/ { skip=1; next }
    skip && /^# / { skip=0 }
    skip && /^## / { skip=0 }
    !skip { print }
  '
}

redact_stream() {
  sed -E \
    -e 's/AKIA[0-9A-Z]{16}/[REDACTED]/g' \
    -e 's/ASIA[0-9A-Z]{16}/[REDACTED]/g' \
    -e 's/AIza[0-9A-Za-z_-]{35}/[REDACTED]/g' \
    -e 's/xox[baprs]-[0-9A-Za-z-]{10,48}/[REDACTED]/g' \
    -e 's/ghp_[0-9A-Za-z]{36}/[REDACTED]/g' \
    -e 's/ghs_[0-9A-Za-z]{36}/[REDACTED]/g' \
    -e 's/-----BEGIN [A-Z ]+ PRIVATE KEY-----/[REDACTED PRIVATE KEY]/g'
}

emit_sop_head() {
  local file="$1"
  local limit=10
  awk -v limit="$limit" '
    BEGIN { count=0 }
    /^## [0-9]{4}-[0-9]{2}-[0-9]{2} / {
      count++
      if (count > limit) {
        exit
      }
    }
    { print }
  ' "$file"
}

emit_file() {
  local path="$1"
  local out_file="$2"

  printf '## %s\n' "$path" >> "$out_file"
  if [[ "$path" == "SoP.md" ]]; then
    emit_sop_head "${REPO_ROOT}/${path}" | strip_toc | redact_stream >> "$out_file"
  else
    strip_toc < "${REPO_ROOT}/${path}" | redact_stream >> "$out_file"
  fi
  printf '\n\n' >> "$out_file"
}

include_small() {
  local path="$1"
  case "$path" in
    TRUTH.md|AGENTS.md|SoP.md|docs/library/INDEX.md)
      return 0
      ;;
    docs/library/skills/S-LEARN-0[1-9].md|docs/library/skills/S-LEARN-10.md)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

include_full() {
  local path="$1"
  if include_small "$path"; then
    return 0
  fi
  case "$path" in
    README.md)
      return 0
      ;;
    docs/library/*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

rm -f "$SMALL_OUT" "$FULL_OUT"

declare -A seen_small
declare -A seen_full

while IFS= read -r path; do
  if include_small "$path"; then
    if [[ -z "${seen_small[$path]:-}" ]]; then
      emit_file "$path" "$SMALL_OUT"
      seen_small[$path]=1
    fi
  fi
  if include_full "$path"; then
    if [[ -z "${seen_full[$path]:-}" ]]; then
      emit_file "$path" "$FULL_OUT"
      seen_full[$path]=1
    fi
  fi
done < <(git ls-files | sort)

if [[ ! -s "$SMALL_OUT" ]]; then
  echo "ERROR: ${SMALL_OUT} is empty" >&2
  exit 1
fi

if [[ ! -s "$FULL_OUT" ]]; then
  echo "ERROR: ${FULL_OUT} is empty" >&2
  exit 1
fi

printf 'Wrote %s and %s\n' "$SMALL_OUT" "$FULL_OUT"
