#!/usr/bin/env bash
set -euo pipefail

scope="platform"
format="chatgpt"
out_path=""
compress_mode=""
bundle_mode=0
max_lines=0
target=""

usage() {
  cat <<'USAGE'
Usage: ops/bin/dump [--scope=platform|full|project] [--target=<slug>] [--format=chatgpt|gemini|claude]
                   [--max-lines=n] [--out=path|auto] [--compress=tar.xz] [--bundle]
USAGE
}

die() {
  echo "ERROR: $*" >&2
  usage >&2
  exit 1
}

for arg in "$@"; do
  case "$arg" in
    --scope=platform|--scope=full|--scope=project)
      scope="${arg#--scope=}"
      ;;
    --target=*)
      target="${arg#--target=}"
      if [[ -z "$target" ]]; then
        die "--target requires a value"
      fi
      ;;
    --format=chatgpt|--format=gemini|--format=claude)
      format="${arg#--format=}"
      ;;
    --max-lines=*)
      max_lines="${arg#--max-lines=}"
      if [[ -z "$max_lines" ]]; then
        die "--max-lines requires a value"
      fi
      if ! [[ "$max_lines" =~ ^[0-9]+$ ]]; then
        die "--max-lines must be a non-negative integer"
      fi
      ;;
    --out=*)
      out_path="${arg#--out=}"
      if [[ -z "$out_path" ]]; then
        die "--out requires a path"
      fi
      if [[ "$out_path" == "auto.tar.xz" ]]; then
        out_path="auto"
        compress_mode="tar.xz"
      fi
      ;;
    --compress=tar.xz)
      compress_mode="tar.xz"
      ;;
    --bundle|--bundle=receipt)
      bundle_mode=1
      ;;
    *)
      die "Unknown argument: $arg"
      ;;
  esac
done

if [[ "$scope" == "project" && -z "$target" ]]; then
  die "--scope=project requires --target=<slug>"
fi

if [[ "$scope" != "project" && -n "$target" ]]; then
  die "--target is only valid with --scope=project"
fi

if [[ -n "$target" && "$target" == */* ]]; then
  die "--target must be a project slug"
fi

if [[ -n "$out_path" && "$out_path" != "auto" && -z "$compress_mode" ]]; then
  case "$out_path" in
    *.tar.xz)
      compress_mode="tar.xz"
      ;;
  esac
fi

if [[ -n "$compress_mode" && -z "$out_path" ]]; then
  die "--compress requires --out"
fi

if [[ "$bundle_mode" -eq 1 && -n "$out_path" && -z "$compress_mode" ]]; then
  compress_mode="tar.xz"
fi

if [[ "$scope" == "full" && "$out_path" == "auto" && -z "$compress_mode" ]]; then
  compress_mode="tar.xz"
fi

if ! command -v git >/dev/null 2>&1; then
  die "git is required but was not found on PATH."
fi

if ! repo_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  die "git repo not found. Run from repo root."
fi

if [[ "$(pwd -P)" != "$repo_root" ]]; then
  die "Run from repo root: $repo_root"
fi

required_files=("TRUTH.md" "SoP.md" "AGENTS.md")
missing=()
for path in "${required_files[@]}"; do
  if [[ ! -f "$path" ]]; then
    missing+=("$path")
  fi
done
if (( ${#missing[@]} > 0 )); then
  echo "ERROR: expected files missing. Run from repo root." >&2
  for path in "${missing[@]}"; do
    echo "  - $path" >&2
  done
  exit 1
fi

for dir in docs tools ops .github; do
  if [[ ! -d "$dir" ]]; then
    missing+=("$dir/")
  fi
done
if (( ${#missing[@]} > 0 )); then
  echo "ERROR: expected directories missing. Run from repo root." >&2
  for path in "${missing[@]}"; do
    echo "  - $path" >&2
  done
  exit 1
fi

if [[ "$scope" == "project" ]]; then
  if [[ ! -d "projects/$target" ]]; then
    die "Project not found: projects/$target"
  fi
fi

mkdir -p "$repo_root/storage/handoff"
mkdir -p "$repo_root/storage/dumps"

remote_url="$(git remote get-url origin 2>/dev/null || true)"
if [[ -n "$remote_url" ]]; then
  repo_name="$(basename -s .git "$remote_url")"
else
  repo_name="$(basename "$repo_root")"
fi

branch="$(git rev-parse --abbrev-ref HEAD)"
head_short="$(git rev-parse --short HEAD)"
branch_safe="${branch//\//-}"
dump_base="dump-${scope}-${branch_safe}-${head_short}"
payload_path="$repo_root/storage/dumps/${dump_base}.txt"
manifest_path="$repo_root/storage/dumps/${dump_base}.manifest.txt"

format_label="$format"
case "$format" in
  chatgpt)
    format_label="ChatGPT"
    ;;
  gemini)
    format_label="Gemini"
    ;;
  claude)
    format_label="Claude"
    ;;
esac

include_file() {
  local path="$1"
  case "$scope" in
    full)
      return 0
      ;;
    platform)
      [[ "$path" != projects/* ]]
      return $?
      ;;
    project)
      if [[ "$path" == "projects/$target/"* ]]; then
        return 0
      fi
      [[ "$path" != projects/* ]]
      return $?
      ;;
  esac
}

files=()
mapfile -t all_files < <(git ls-files)
for path in "${all_files[@]}"; do
  if include_file "$path"; then
    files+=("$path")
  fi
done

if (( ${#files[@]} == 0 )); then
  die "No files selected for scope: $scope"
fi

output_target=""
archive_path=""
if [[ -n "$out_path" ]]; then
  if [[ "$out_path" == "auto" ]]; then
    if [[ "$compress_mode" == "tar.xz" ]]; then
      output_target="$repo_root/storage/dumps/${dump_base}.tar.xz"
    else
      output_target="$payload_path"
    fi
  elif [[ "$out_path" = /* ]]; then
    output_target="$out_path"
  else
    output_target="$repo_root/$out_path"
  fi
fi
if [[ -z "$output_target" ]]; then
  archive_path="$repo_root/storage/dumps/${dump_base}.tar.xz"
elif [[ "$compress_mode" == "tar.xz" ]]; then
  archive_path="$output_target"
fi
mkdir -p "$(dirname "$payload_path")"
if [[ -n "$output_target" ]]; then
  mkdir -p "$(dirname "$output_target")"
fi

display_path() {
  local path="$1"
  if [[ -z "$path" ]]; then
    return 0
  fi
  if [[ "$path" == "$repo_root"/* ]]; then
    printf "./%s" "${path#"$repo_root"/}"
  else
    printf "%s" "$(basename "$path")"
  fi
}

count_lines() {
  awk 'END { print NR }' "$1"
}

emit_file_contents() {
  local path="$1"
  local suppress_pipe_errors="$2"
  local max="$3"
  if [[ ! -f "$path" ]]; then
    echo "(missing file)"
    return 0
  fi
  if (( max > 0 )); then
    if [[ "$suppress_pipe_errors" -eq 1 ]]; then
      awk -v max="$max" '{
        total++
        if (total <= max) {
          print
        }
      }
      END {
        if (total > max) {
          print "(...truncated at " max " lines; use --max-lines=0 for complete)"
        }
      }' "$path" 2>/dev/null || true
    else
      awk -v max="$max" '{
        total++
        if (total <= max) {
          print
        }
      }
      END {
        if (total > max) {
          print "(...truncated at " max " lines; use --max-lines=0 for complete)"
        }
      }' "$path"
    fi
  else
    if [[ "$suppress_pipe_errors" -eq 1 ]]; then
      cat "$path" 2>/dev/null || true
    else
      cat "$path"
    fi
  fi
}

is_file_truncated() {
  local path="$1"
  local lines

  if [[ ! -f "$path" ]]; then
    return 1
  fi

  if (( max_lines > 0 )); then
    lines=$(count_lines "$path")
    if (( lines > max_lines )); then
      return 0
    fi
  fi
  return 1
}

emit_dump() {
  local suppress_pipe_errors=0
  local files_count
  local truncated_files=0

  if [[ -p /proc/$$/fd/1 ]]; then
    suppress_pipe_errors=1
    exec 2>/dev/null
  fi

  files_count=${#files[@]}
  for path in "${files[@]}"; do
    if is_file_truncated "$path"; then
      truncated_files=$((truncated_files + 1))
    fi
  done

  echo "===== REPO DUMP ====="
  echo "Dump generated by [System] at ./"
  echo "Repo: $repo_name"
  echo "Branch: $branch"
  echo "HEAD: $head_short"
  echo "Scope: $scope"
  if [[ "$scope" == "project" ]]; then
    echo "Target: $target"
  fi
  echo "Format: $format_label"
  echo "Files included: $files_count"
  echo "Truncated files: $truncated_files"
  case "$scope" in
    platform)
      echo "Excluded dirs: projects/"
      ;;
    project)
      echo "Excluded dirs: projects/* (except projects/$target/)"
      ;;
    full)
      echo "Excluded dirs: none"
      ;;
  esac
  echo "Excluded types: none"
  echo "===== DUMP PAYLOAD BEGIN ====="
  echo "[INDEX]"
  for path in "${files[@]}"; do
    echo "- $path"
  done
  echo ""
  echo "[FILE CONTENTS]"
  for path in "${files[@]}"; do
    echo "<<< FILE BEGIN: $path"
    emit_file_contents "$path" "$suppress_pipe_errors" "$max_lines"
    echo ">>> FILE END: $path"
    echo ""
  done
  echo "===== DUMP PAYLOAD END ====="
}

emit_manifest() {
  local path="$1"
  local payload="$2"
  local output="$3"
  local files_count="${#files[@]}"
  {
    echo "Dump Manifest"
    echo "Branch: $branch"
    echo "HEAD: $head_short"
    echo "Scope: $scope"
    if [[ "$scope" == "project" ]]; then
      echo "Target: $target"
    fi
    echo "Format: $format_label"
    echo "Dump payload: $(display_path "$payload")"
    if [[ -n "$output" ]]; then
      echo "Output target: $(display_path "$output")"
    else
      echo "Output target: (stdout)"
    fi
    echo "Files included: $files_count"
    echo "Included files:"
    for path in "${files[@]}"; do
      echo "- $path"
    done
  } > "$path"
}

emit_dump > "$payload_path"

manifest_output="$output_target"
if [[ -z "$manifest_output" && -n "$archive_path" ]]; then
  manifest_output="$archive_path"
fi

if [[ "$bundle_mode" -eq 1 ]]; then
  emit_manifest "$manifest_path" "$payload_path" "$manifest_output"
fi

if [[ -z "$output_target" ]]; then
  cat "$payload_path"
fi

if [[ -n "$archive_path" ]]; then
  if ! command -v tar >/dev/null 2>&1; then
    die "tar is required for dump archive output but was not found on PATH."
  fi
  tar_items=()
  tar_items+=("$(basename "$payload_path")")
  if [[ "$bundle_mode" -eq 1 ]]; then
    tar_items+=("$(basename "$manifest_path")")
  fi
  tar -cJf "$archive_path" -C "$(dirname "$payload_path")" "${tar_items[@]}"
elif [[ -n "$output_target" && "$output_target" != "$payload_path" ]]; then
  cp "$payload_path" "$output_target"
fi

if [[ "$bundle_mode" -eq 0 ]]; then
  emit_manifest "$manifest_path" "$payload_path" "$manifest_output"
fi

echo "Dump payload: $(display_path "$payload_path")"
if [[ -n "$archive_path" ]]; then
  echo "Dump tarball: $(display_path "$archive_path")"
fi
echo "Dump manifest: $(display_path "$manifest_path")"
